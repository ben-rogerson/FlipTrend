import { type Radar } from 'react-chartjs-2'

interface RadarColors {
  color: string
  backgroundColor: string
  borderColor: string
}

/**
 * Creates a map of colors for a radar chart.
 * The colors are generated by interpolating between two colors.
 * The first value begins at 0 and the last value ends at the supplied numColors.
 * @param highColor - The hsl color of the radar chart when the value is highest.
 * @param lowColor - The hsl color of the radar chart when the value is lowest.
 * @param numColors - The number of colors to generate.
 * @returns A map of colors for the radar chart.
 * @example
 * const highColor = \{ h: 70, s: 76, l: 61 \};
 * const lowColor = \{ h: 11, s: 76, l: 61 \};
 * const radarColors = getRadarColors(highColor, lowColor, 30);
 */
export const getRadarColors = (
  highColor: { h: number; s: number; l: number },
  lowColor: { h: number; s: number; l: number },
  numColors: number
): Map<number, RadarColors> => {
  if (numColors < 2) throw new Error('numColors must be greater than 1')

  const radarColors = new Map<number, RadarColors>()
  const hueStep = (highColor.h - lowColor.h) / (numColors - 1)
  const saturationStep = (highColor.s - lowColor.s) / (numColors - 1)
  const lightnessStep = (highColor.l - lowColor.l) / (numColors - 1)

  for (let i = 0; i <= numColors; i++) {
    const hue = Math.round(lowColor.h + i * hueStep)
    const saturation = lowColor.s + i * saturationStep
    const lightness = lowColor.l + i * lightnessStep

    radarColors.set(i, {
      color: `hsl(${hue}deg ${saturation - 25}% ${lowColor.l - 20}%)`,
      backgroundColor: `hsl(${hue}deg ${saturation}% ${lightness}% / 70%)`,
      borderColor: `hsl(${hue}deg ${saturation}% ${lightness}%)`,
    })
  }

  return radarColors
}

type RadarOptions = Parameters<typeof Radar>[0]['options']

/**
 * Creates options for a 'react-chartjs-2' Radar chart.
 * @param colorGridBg - The background color of the radar chart.
 * @param colorGridLine - The color of the grid lines.
 */
export const getRadarOptions = (
  colorGridBg: string,
  colorGridLine: string
): RadarOptions => ({
  animation: false,
  elements: { point: { radius: 0 } },
  plugins: { legend: { display: false } },
  scales: {
    r: {
      max: 6,
      min: -2, // Add center space to improve chart readability with low scores
      backgroundColor: colorGridBg,
      ticks: { display: false },
      pointLabels: { display: false },
      angleLines: { lineWidth: 2, color: colorGridLine },
      grid: {
        circular: true,
        lineWidth: 2,
        color: [
          // Invisible center lines improve chart readability with low scores
          'transparent',
          'transparent',
          colorGridLine,
          colorGridLine,
          colorGridLine,
          colorGridLine,
          colorGridLine,
          colorGridLine,
          colorGridLine,
        ],
      },
    },
  },
})

/**
 * Creates a path for a svg circle path.
 * @param cx - The x-coordinate of the center of the circle.
 * @param cy - The y-coordinate of the center of the circle.
 * @param r - The radius of the circle.
 * @param deg - The degree placed on the circle.
 * @param type - If positioned on the inside/outside of the circle.
 * @example
 * ```ts
 * <svg><path d={getSvgCirclePath(100, 100, 50, 90, 'inner')} /></svg>
 * ```
 */
export const getSvgCirclePath = (
  cx: number,
  cy: number,
  r: number,
  deg: number,
  type: 'inner' | 'outer' = 'outer'
) => {
  const theta = (deg * Math.PI) / 180
  const dx = r * Math.cos(theta)
  const dy = -r * Math.sin(theta)
  const direction = type === 'outer' ? 1 : 0

  return `M ${cx} ${cy} m ${dx},${dy} a ${r},${r} 0 1,${direction} ${-2 * dx},${
    -2 * dy
  } a ${r},${r} 0 1,${direction} ${2 * dx},${2 * dy}`
}
